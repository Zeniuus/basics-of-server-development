# 네이티브 클라이언트 개발 시 서버의 유의사항

## 앱 vs 웹

네이티브 클라이언트(이하 앱)과 웹의 차이는 크게 두 가지 측면으로 나눠서 볼 수 있다.

첫 번째는 사용성 측면이다. 대체로 앱의 사용성이 웹보다 훨씬 뛰어나다.

- 웹은 리소스를 항상 다운받아야 한다. 반면 앱은 설치할 때 리소스를 대부분 다운받아 놓을 수 있다. 따라서 앱은 일단 설치하기만 하면 네트워크에 의한 딜레이가 많이 줄어든다.
- 앱은 푸시를 보낼 수 있지만, 웹은 불가능하다.
- 앱은 오프라인에서도 동작할 수 있지만, 웹은 페이지 로딩조차 안 된다.

하지만, 서비스에 대한 제어(controllability) 측면에서는 웹이 앱보다 매우 유리하다. 웹은 웹서버를 새로 배포하면 그 이후로 웹에 접근하는 사람들은 모두 새로운 버전을 본다(캐시 예외). 반면 앱은 강제 업데이트를 시키거나 유저가 업데이트 하지 않는 이상 구 버전의 앱이 그대로 남아 있다. 따라서 앱으로 서비스를 운영하는 경우, 새로운 기능을 개발하거나 사용성을 개선하더라도 유저가 직접 업데이트를 하지 않는 한 해당 패치를 적용받을 수 없다.

이러한 특성을 고려하여, 최근에는 기본적으로 앱으로 구현하되 자주 변경될 여지가 있는 부분은 [웹뷰](https://developer.android.com/reference/android/webkit/WebView)를 통해 웹으로 처리하는 경우가 많은 것 같다.

위 내용 중 서버에서 중요시 여겨야 할 부분은, 앱으로 구현하는 경우 앱 버전을 제어하기 어렵다는 점이다. 위에서 언급한 대로 앱의 업데이트는 앱을 개발하는 쪽이 아니라 사용하는 쪽이 자발적으로 해주어야 한다. 따라서 사용자가 앱을 오랫동안 업데이트하지 않는다면 구 버전의 앱이 상당히 오래 남아 있을 수 있다. 강제 업데이트를 하는 방법이 있지만, 이는 유저의 사용성을 크게 해치므로 웬만하면 피해야 한다. 따라서 서버는 구 버전의 앱이 오래 남아 있을 것을 대비해야 한다.

구체적으로, 앱으로 서비스를 개발할 때 서버에서 고려해야 할 것은 크게 두 가지이다.

- 하위호환성 고려
- 강제 업데이트 전략

## 하위호환성 고려

API의 하위호환성이란, 구 버전의 앱이 서버의 API를 호출해도 정상 동작함을 보장하는 성질이다. 서버는 새로운 버전의 앱이 배포되더라도 구 버전의 앱이 남아 있을 수 있다는 것을 충분히 고려해서, 구 버전의 앱도 정상적으로 동작할 수 있도록 해야 한다.

- 서버는 구 버전의 앱이 사용하는 API endpoint를 계속 노출해야 한다. 새로운 버전의 앱에서 더 이상 사용하지 않는 API도 바로 삭제하면 안 되고, 그 API를 쓰는 버전의 앱이 더 이상 없다는 것이 보장될 때만 삭제해야 한다. 보통 API를 deprecate 시켜놓고, 이후에 앱을 강제 업데이트하면 API를 삭제한다.
- 서버는 구 버전의 앱이 올려주는 request body를 이해할 수 있어야 한다. 이는 크게 request body에 필드를 추가하는 케이스와 삭제하는 케이스로 구분해서 볼 수 있다. 필드의 시멘틱이나 타입을 변경하는 건 하위호환성을 지키는 게 까다로워지므로 최대한 지양해야 한다.
    - 필드 추가 - 새 버전의 앱을 위해 request body에 새로운 필드가 추가된 경우이다. 이 경우, 구 버전의 앱은 이 필드를 비운 채로 API 요청을 보내게 된다. 서버는 필드가 비워져서 온 요청을 핸들링할 수 있어야 한다.

        이를 위해서는 request body의 deserializer가 적절히 구현되어 있어야 한다. 필드가 비워져 있을 경우 에러를 내는 게 아니라 default value(e.g. 문자열 타입이면 빈 문자열, 숫자 타입이면 0 등)나 null로 변환해줘야 한다.

        deserializer가 빈 필드를 default value로 변환하는 경우 한 가지 고려해야 할 점이 있다. 이 경우, 서버는 앱이 애초에 default value를 올려준 건지, 아니면 앱은 해당 필드를 비워서 올려줬는데 deserializer가 default value로 변환해준 건지 구분할 수 없다. 만약 이 두 가지를 서버가 구분할 필요가 있는 상황이라면 request body에 필드를 추가할 때 nullable한 필드로 추가하는 것이 좋다.

    - 필드 삭제 - request body에서 더 이상 필요하지 않은 필드를 삭제한 경우이다. 이 경우, 구 버전의 앱은 이 필드를 계속 채워준 상태로 API 요청을 보내게 된다. 서버는 프로토콜 상에는 없는 필드가 request body에 담겨 있는 상황을 핸들링할 수 있어야 한다.

        이 문제는 간단하게 해결할 수 있다. deserializer가 모르는 필드를 무시하도록 설정해놓으면 된다.

- 서버는 구 버전의 앱이 이해할 수 있도록 response를 내려줘야 한다. 이는 바로 위의 고려사항에서 앱과 서버의 입장이 뒤바뀐 것이라고 할 수 있다. 따라서 response body에서 필드가 추가/삭제된 경우는 앱쪽에서 제대로 처리해줘야 한다. 앱의 deserializer는 response body의 필드가 비워져 있는 경우와 모르는 필드가 존재하는 경우를 적절히 처리할 수 있어야 한다.

## 강제 업데이트 전략

앱의 강제 업데이트는 유저의 사용성을 크게 해치고 앱 사용자를 이탈시킬 가능성이 높기 때문에 최대한 피해야 한다. 하지만 골든 패스에 영향을 주는 큰 변경의 경우 반드시 모든 유저에게 적용되어야 할 필요가 있을 때도 있다. 이런 경우에는 앱을 강제로 업데이트해야 한다.

앱의 강제 업데이트는 앱을 처음 출시할 때부터 고려해놓아야 가능하다. 구체적으로, 다음과 같은 기반 작업이 미리 선행되어야 한다.

1. 앱은 서버에 자신의 버전을 알려줄 수 있어야 한다. e.g. 사전에 약속된 방식으로 HTTP Header에 앱 버전을 담아서 요청을 보낸다. 이는 서버가 앱의 버전을 보고 강제 업데이트가 필요한지 판단하기 위함이다.
2. 서버는 앱이 강제 업데이트가 필요한 경우 앱에 강제 업데이트가 필요하다는 것을 알려줄 수 있어야 한다. e.g. 강제 업데이트가 필요한 경우 사전에 약속된 에러를 발생시킨다.
3. 앱은 2번을 통해 강제 업데이트가 필요함을 인지하면 앱 사용을 막고 앱마켓으로 보내야 한다.

강제 업데이트를 위한 기반 작업을 설계할 때 몇 가지 주의해야 할 사항이 있다.

- 앱에 강제 업데이트가 필요한 경우, 사용자의 앱 사용을 막아야 한다. 이를 위해서 서버는 강제 업데이트가 필요한 앱이 API를 호출한 경우 비즈니스 로직을 실행하는 대신 에러를 내야 한다.
- 앱의 사용성을 고려하여 강제 업데이트 시점을 신중하게 선택해야 한다. 서비스 특성 상 앱이 강제 업데이트가 되면 안 되는 시점이 존재할 수 있는데, 이런 플로우는 피해서 2번과 3번 로직을 심어야 한다.

## Refs

- [https://vwo.com/blog/10-reasons-mobile-apps-are-better/](https://vwo.com/blog/10-reasons-mobile-apps-are-better/)
- [https://developer.android.com/reference/android/webkit/WebView](https://developer.android.com/reference/android/webkit/WebView)
