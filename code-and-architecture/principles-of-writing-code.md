# 코드 작성 원칙

이전에 이규원님이 작성하신 글 중에 [좋은 코드란 없고, 상황에 따른 적절한 코드만 존재한다는 논지의 글](https://gyuwon.github.io/blog/2020/07/31/what-is-good-code.html)이 있었다. 여기에 동의한다. 하지만 어떤 상황에서도 되도록이면 지키기 위해 노력해야 하는 공통된 개발 원칙들이 있다고 생각한다. 기본적으로는 이 원칙을 지키고, 필요에 따라 이 원칙과 다른 가치(e.g. 빠른 개발을 통한 proof of concept)를 트레이드 오프 하는 것이다.

이런 트레이드 오프가 가능하려면 우선 소프트웨어를 개발할 때 어떤 원칙을 지켜야 하고, 각 원칙이 어떤 효과를 가져다 주는지를 잘 이해하고 있어야 한다.

## 프로덕션 레벨의 소프트웨어가 가져야 하는 성질

나는 직군에 관계 없이 개발자가 두 가지 역할을 수행해야 한다고 생각한다.

- 요구사항을 만족하는 올바른 소프트웨어를 작성한다.
- 비즈니스 가치를 빠르게 전달할 수 있는 소프트웨어를 작성한다.

하지만 이 두 가지를 지키는 소프트웨어를 작성하는 것은 매우 어려운 일이다. 사업이 발전함에 따라 소프트웨어는 점점 거대해지고, 필연적으로 복잡해진다. 한 명의 개발자가 읽을 수 있는 코드의 양에는 한계가 있고, 엔터프라이즈 어플리케이션의 코드베이스 규모는 이 한계를 빠른 속도로 훌쩍 뛰어 넘는다. 기존에 있는 기능을 조금 수정해야 하는 상황을 생각해보자. 코드의 어떤 부분을 수정해야 하는지 파악하는 데에 한참이 걸리고, 기능 하나를 수정하기 위해 온갖 코드를 수정해야 하고, 코드를 조금 수정했을 뿐인데 엉뚱한 곳에서 버그가 터지는 일은 비일비재하게 발생한다.

따라서 위 두 가지 역할을 제대로 수행하기 위해, 개발자는 소프트웨어가 다음의 성질을 가지도록 소프트웨어를 작성해야 한다.

- **소프트웨어의 가독성** - 얼마나 빠르게 코드를 파악할 수 있는가?
- **소프트웨어의 자율성** - 얼마나 독립적으로 코드를 변경하고 프로덕션으로 배포할 수 있는가?
- **소프트웨어의 개발 속도** - 같은 기능을 얼마나 빠르게 반영할 수 있는가?

다행히 이미 많은 소프트웨어 개발의 대가들이 같은 고민을 했고, 위와 같은 소프트웨어를 만들기 위한 수많은 방법론을 고안해냈다. 이런 방법론을 공부할 때 공통적으로 등장하는 개념과 추구하는 목표가 몇몇 존재하는데, 이들을 정리해보았다.

## 원칙 1. 의존성의 올바른 관리

거대하고 복잡한 소프트웨어는 수많은 소프트웨어 컴포넌트들의 통합과 협업을 통해 만들어진다. 코드 레벨에서는 다른 클래스의 변수 및 전역 변수를 사용하거나 함수를 호출한다. 프로세스 레벨에서는 네트워크 통신을 통해 다른 서버가 노출하는 API를 사용하거나, 다른 프로세스가 저장해놓은 데이터를 가져다 사용할 수도 있다. 이렇게 한 소프트웨어 컴포넌트가 다른 소프트웨어 컴포넌트의 기능을 직/간접적으로 가져다 사용하는 것을 '**의존**'이라고 부른다.

의존은 소프트웨어를 작성할 때 필연적으로 발생하지만, 의존을 올바르게 하지 않으면 문제가 발생한다. A라는 소프트웨어 컴포넌트가 B라는 소프트웨어 컴포넌트에 의존하는 상황을 생각해보자(A→B). 이 경우 A를 변경하는 것은 큰 문제가 안 된다. 반면, B를 수정하는 것은 조금 골치 아프다. B를 수정할 때 A가 올바르게 동작하는 것까지 고려해야 하기 때문이다.

- B의 기능을 변경하려면 B에 대한 새 요구사항을 지키는 것뿐만 아니라 A가 B의 기능을 사용하는 유즈 케이스에 대해서도 요구사항이 지켜져야만 한다.
- 만약 B의 인터페이스를 바꿔야 하는 상황이라면 더욱 문제가 크다. 필연적으로 A에서 B를 사용하는 코드도 함께 수정해야 하기 때문이다.
- 만약 A가 다른 팀이 관리하고 있는 컴포넌트라면 B의 변경 비용은 더욱 커질 것이다. B를 수정해야 하는 필요성에 대해 다른 팀을 설득하고, A에 대한 하위호환성도 고려해야 한다.
- 만약 B에 의존하는 소프트웨어 컴포넌트가 더 많다면(C→B, D→B, ...) B의 변경 비용은 더욱 커질 것이다.

**위에서 본 것처럼, 의존성은 소프트웨어 변경의 비용을 높인다. 따라서 의존성을 올바르게 관리하는 것이 필요하다.**

의존성의 관리는 결국 코드를 어떻게 분리하고 어디에 연관시킬 것이냐에 대한 이야기이다. 컴포넌트를 분리할 경계를 신중하게 선택하지 않으면 클래스/함수가 예상치 못한 이유로 서로에게 의존하게 되고, 소프트웨어는 점점 거대한 진흙덩어리(big ball of mud)가 되어간다.

- 한 클래스에서 기능을 개발할 때 다른 객체의 필드를 자꾸만 조회/변경할 일이 생긴다.
- 같은 코드를 여기저기로 복사해서 사용해야 하는 상황에 처한다.
- 수많은 분기로 인해 점점 유지보수하기 어려운 코드가 만들어진다.
- cyclic dependency가 자꾸만 발생한다.

반대로, 적절한 경계를 기준으로 클래스/함수를 나누면 서로 관련 있는 코드가 한 클래스/함수에 묶일 것이기 때문에 의존성을 최소화할 수 있다.

다음은 의존성을 올바르게 관리하기 위한 몇 가지 팁이다.

### 계층 아키텍처를 사용한다.
계층 아키텍처란, 소프트웨어를 여러 레이어로 나누어서 설계하는 것을 의미한다. 여기서는 필자가 선호하는 DDD(Domain-Driven Design)의 4계층 아키텍처를 설명한다.

- 유저 인터페이스 계층 - 유저 인터페이스와의 인터렉션을 담당하는 계층이다. 인증, form에 대한 validation, DTO의 변환 등을 담당한다.
- 어플리케이션 계층 - 어플리케이션의 유스케이스가 구현되는 계층이다. 각 메소드는 유스케이스 하나를 표현하며, 도메인 계층의 함수를 적절한 순서로 호출하여 유즈케이스의 요구사항을 만족시킨다. 또한 트랜잭션 경계의 조절, 유저에 대한 notification(SMS/푸시/이메일 등) 등이 이루어지는 계층이다.
- 도메인 계층 - DDD의 표현을 빌리자면 "비즈니스 로직이 살아 숨쉬는 계층"이다. 필자는 이 표현이 잘 와닿지 않아 별로 좋아하지 않는데, 필자 마음대로 고쳐서 설명자하면 "어플리케이션 계층에서 사용할 수 있는 정제된 동작의 집합"이라고 생각하고 있다.
- 인프라 계층 - 위의 세 가지 계층에 대한 기술적인 지원을 하는 계층이다. ORM, 네트워크 통신, serialization/deserialization 등을 담당한다.

계층 아키텍처의 장점은 설계에 대한 고민을 보다 간단하게 만들어준다는 것이다. 이 4계층 아키텍처는 엔터프라이즈 어플리케이션에서 주로 발생하는 기술적인 측면의 설계 고민을 많이 해결해준다. 덕분에 개발자는 각 계층, 특히 대다수의 복잡성이 발생하는 도메인 계층을 어떻게 설계할지에 대해서만 집중해서 고민할 수 있게 된다.

### 구체적인 것이 추상적인 것에 의존한다.
조금 다른 말로 바꿔서 이야기하면, 재사용성이 낮은 것이 재사용성이 높은 것에 의존해야 한다.
   
위의 계층 구조를 예시로 들어보자. 도메인 계층에는 어플리케이션의 각 유즈케이스에서 재사용할 동작들이 모여 있다. 이런 상황에서 도메인 계층이 어플리케이션 계층에 의존하면 어떻게 될까? 도메인 계층의 동작이 특정 유즈케이스에만 종속적인 동작을 포함하게 될 수도 있다. 이러면 크게 두 가지 문제가 발생한다.

- 도메인 계층의 재사용성이 떨어진다 - 도메인 계층의 동작이 의존하는 유즈케이스 외의 다른 유즈케이스에서는 해당 동작을 재사용하기 어려워질 수 있다.
- 코드의 응집력이 떨어진다 - 유즈케이스에 대한 지식이 도메인 계층으로 퍼지게 되면서, 해당 유즈케이스와 관련된 코드가 도메인 계층와 어플리케이션 계층 모두에 존재하게 된다. 이러면 나중에 해당 유즈케이스를 변경해야 하는 시점에 두 군데의 코드를 수정해야 해서 변경이 더 어려워진다.

하지만 함수의 호출 플로우를 언제나 구체적인 것에서 추상적인 것으로 만들 수 있는 것은 아니다. 예를 들어, 도메인 계층의 특정 동작이 끝난 경우 어플리케이션 계층의 동작이 실행되어야 한다고 하자. 이 경우에는 어떤 방식으로든 도메인 계층이 어플리케이션 계층의 함수를 호출해야만 한다. 하지만 위에서 확인한 대로 이는 별로 바람직하지 않은 의존성이다.

의존성 역전 원칙(Dependency Inversion Principle, DIP)은 바로 이런 문제를 해결하기 위해 탄생한 것이다. 의존성 역전 원칙의 개념은 callback을 통해 아주 쉽게 이해할 수 있다. 자바스크립트의 `setTimeout()` 예시를 들어보자. 이 함수는 함수 하나와 숫자 하나를 인자로 받아서, 해당 숫자만큼의 millisecond가 지나면 함수를 실행하는 단순한 함수이다. 이 때 우리가 다음과 같은 코드를 작성했다고 하자. 이 때 의존성은 어떻게 될까?

```jsx
const func = () => console.log('Hello, world!');
setTimeout(func, 1000);
```

함수 호출의 플로우는 `setTimeout()` → `func` 이다. 하지만 `setTimeout()`의 구현은 우리가 작성한 코드와 전혀 관계가 없기 때문에, `setTimeout()`은 우리 코드에 의존하지 않는다. 반면, 우리 코드는 `setTimeout()`을 호출하므로 `setTimeout()`에 의존한다. 좀 더 정확히 말하면, 우리는 `setTimeout(callback, millis)`이라는 인터페이스, "즉 `millis` millisecond 이후에 `callback` 이라는 함수를 실행시킨다"는 '약속'에 의존하는 것이다. 즉, 함수 호출 플로우에 역전된 의존성을 가지게 된다.

이처럼, DIP를 사용하여 추상적인 계층이 인터페이스를 노출하고 구체적인 계층이 해당 인터페이스에 의존하는 방식으로 의존성을 함수 호출 플로우에 역전시킬 수 있고, 이를 통해 구체적인 것이 추상적인 것에 의존한다는 규칙을 지켜나갈 수 있다.

### 의존 포인트를 통합한다.
다음과 같은 상황을 생각해보자. 한 어플리케이션에 결제 로직을 처리하는 소프트웨어들이 모여 있는 payment 모듈이 있다. 이 모듈에는 결제를 담당하는 `PayService`, 전체 환불을 담당하는 `RefundService`, 부분환불을 담당하는 `PartialRefundService`가 구현되어 있다. 그리고 어플리케이션의 다른 소프트웨어 컴포넌트는 이 3개의 서비스에 직접 의존한다. 이러한 상황은 payment 모듈의 변경을 어렵게 만든다. 전체 환불과 부분 환불을 담당하는 두 서비스를 하나의 서비스로 합치거나, 비대해진 `PayService`를 분리하는 등의 리팩토링을 하려면 payment 모듈에 의존하는 모든 소프트웨어 컴포넌트를 변경해야 한다.

이런 문제를 방지하기 위해, 시스템과 시스템이 서로 의존할 때는 의존 포인트를 하나로 통일해서 관리하는 것이 좋다. 예를 들어, 위의 예시에서 payment 모듈은 `PaymentService`라는 인터페이스(혹은 클래스)를 노출할 수 있다. 해당 인터페이스는 `pay()`, `refund()`, `partialRefund()`를 메소드로 가진다. 어플리케이션에서 결제 로직을 태우고 싶은 다른 컴포넌트는 `PayService`, `RefundService`, `PartialRefundService`가 아니라 `PaymentService`에만 의존한다. 이러면 `PaymentService`를 제외한 payment 모듈의 다른 코드는 변경으로부터 비교적 자유로워진다. 이들이 지켜야 하는 건 `PaymentService`라는 인터페이스의 semantic 뿐이다.

## 원칙 2. 분명한 인터페이스 디자인

아무런 계획 없이 소프트웨어를 작성하다 보면, 구현하기 편한 방식으로 끊어서 컴포넌트를 묶게 된다. 예를 들어 함수를 작성하다가 단순히 길어져서 함수를 분리하는 경우를 생각해보자. 이 때 분리된 함수의 시그니처는 어떻게 될까? 분리된 함수 내에서 사용되지만 선언하지 않아서 IDE에 빨간색으로 표시되는 변수를 인자로 받게 될 가능성이 크다. 이러면 함수의 의미를 파악하기 힘들고, 재사용성이 떨어지게 된다.

**따라서 구현하기 편한 인터페이스가 아니라, 읽고 가져다 쓰기 편한 인터페이스를 작성해야 한다.** 이는 소프트웨어를 작성하는 빈도보다 해당 소프트웨어를 읽고 가져다가 사용하는 빈도가 훨씬 잦기 때문이다. 인터페이스를 통해서 해당 컴포넌트가 하는 일이 분명하게 드러나지 않으면, 해당 컴포넌트를 사용하는 사람은 불안해서 컴포넌트의 내부 구현을 까보게 된다. 이러면 코드를 분리한 이유가 사라진다. 내부 구현을 몰라도 인터페이스만 보면 명확하게 목적과 용도가 파악되는 소프트웨어를 작성해야 한다.

여기서 말하는 인터페이스는 단순히 클래스의 인터페이스만을 포함하는 게 아니다. 소프트웨어 컴포넌트 간의 의존이 발생하는 모든 '접점'을 의미한다. 클래스의 퍼블릭 변수 및 전역 변수의 이름과 타입, 함수의 시그니처, HTTP API, DB 테이블 스키마 등 수많은 다양한 접점이 존재하고, 이들은 모두 일종의 인터페이스로 생각할 수 있다.

좋은 인터페이스를 설계하기 위해서는 아래와 같은 방법이 도움이 된다.

### 단일 시멘틱 원칙을 지킨다.
단일 시멘틱 원칙은 내가 임의로 붙인 이름으로, 하나의 필드 / 함수 / 클래스는 하나의 의미만을 가져야 한다는 원칙이다. 이에 대한 마틴 파울러의 훌륭한 코멘트가 있다. "역할이 둘 이상인 변수가 있다면 쪼개야 한다. 예외는 없다. 역할 하나당 변수 하나다."(\<Refactoring\>)

단일 시멘틱 원칙은 예상치 못한 동작을 방지하기 위함이다. 인터페이스는 결국 내부의 구현을 숨기기 위함(캡슐화)인데, 하나의 필드가 상황에 따라 if문을 타면서 다르게 해석되거나 하나의 함수가 상황에 따라 if문을 타면서 다른 방식으로 동작할 경우에는 인터페이스를 보고 해당 필드 / 함수가 무슨 역할을 하는지 확신하기 어려워진다. 이러면 해당 인터페이스에 의존하고자 하는 개발자는 내부 구현을 까서 읽어봐야 하고, 최악의 경우에는 해당 내부 구현에 맞춰서 자신이 개발하는 컴포넌트 내에서도 분기를 태워야 할 수 있다. 이러면 인터페이스를 사용하는 이유인 캡슐화의 장점을 완전히 잃어버리게 된다.

### 커맨드 쿼리 분리(Command-Query Separation, CQS)
CQS는 단일 시멘틱 원칙과 마찬가지로 예상치 못한 동작을 방지하기 좋은 개발 방법론이다. CQS에 따르면, 개발자는 메소드를 두 가지 종류로 엄격하게 분리해서 작성해야 한다.

- 커맨드(Command) - 사이드 이펙트를 발생시키는 액션. 여기서의 사이드 이펙트는 보통 클래스 내부의 필드 값을 변화시키는 것을 의미하긴 하지만, DB 값 변경이나 네트워크 호출 등의 다른 사이드 이펙트도 모두 포함한다.
- 쿼리(Query) - 데이터를 조회하는 행위. 쿼리에서는 사이드 이펙트가 절대 발생해서는 안 된다.

예를 들어 쿼리 메소드처럼 생긴 함수(`getXXX()`)가 알고 보니 DB 테이블을 수정하고 있었다면 예상치 못한 사이드 이펙트가 발생할 수 있고, 시스템이 잘못 동작할 수 있다.

### 테스트를 작성한다.
테스트 작성은 수많은 이점을 가져다주는데, 여기서는 인터페이스 설계에 초점을 맞춰서 이야기하겠다.

테스트를 작성하면 좋은 인터페이스를 설계하는 데에 큰 도움이 된다. 특정 클래스에 대한 테스트를 작성하면 실제로 해당 클래스를 사용하는 코드를 작성하게 되는데, 이 과정에서 개발자는 인터페이스가 가진 예상치 못한 문제를 맞닥뜨릴 때가 많다.

- 함수의 인자가 부적절하다. e.g. 함수의 인자로 엔티티의 ID를 받게 하고 함수 내부에서 DB를 조회하여 엔티티를 가져오게 했는데, 해당 함수를 호출하는 시점에 엔티티가 이미 존재한다.
- 함수의 반환값이 부적절하다. e.g. 처리의 성공/실패를 boolean으로 반환하게 만들었는데, 실패했을 때의 사유가 추가적으로 필요하다.
- 함수의 책임을 잘못 설정했다. e.g. 두 개 이상의 함수가 항상 같이 호출되거나, 인자의 전처리나 반환값의 후처리를 위한 코드가 반복되어 작성된다.

테스트는 이러한 문제를 사전에 발견하게 해주어, 다른 코드에서 사용하기 더 편한 인터페이스 설계를 유도한다.

## 원칙 3. 높은 코드 응집도

소프트웨어를 작성하다 보면 하나의 기능과 관련된 코드가 여기저기 흩뿌려지는 경우가 많다. 이런 코드베이스에서는 한 가지 기능을 수정할 때 코드의 수많은 부분을 건드려야만 한다. 이는 개발 속도를 현저하게 감소시킨다. 어디를 고쳐야 하는지 일일이 찾아야 하고, 각 부분을 올바르게 수정해야 하고, 수정했을 때 해당 코드에 의존하는 다른 기능들이 영향을 받지 않았는지 확인해야 한다. 함께 고쳐야 하는 부분이 서로 다른 서버에 퍼져 있을 때는 배포 전략도 추가적으로 수립해야 한다.

**따라서 특정한 기능을 수정할 때 코드의 여러 부분을 수정하는 게 아니라 한 부분만 수정하면 되도록 소프트웨어를 유지해야 한다.** 그래야 코드를 수정할 때의 비용이 낮아지고, 비즈니스 가치를 시장에 빠르게 전달할 수 있다.

### 중복된 코드를 만들지 않는다.
코드 중복은 기능의 응집도가 낮다는 것을 알리는 대표적인 시그널이다. 반복되는 코드는 하나로 합쳐야 한다. 이는 간단하고 당연해 보이지만, 실제 프로덕선 레벨에서는 코드 중복이 빈번하게 발생한다. 왜냐하면 생각보다 지키기 어렵기 때문이다.

함수를 예시로 들어보자. 완전히 동일한 함수를 복사-붙여넣기해서 중복이 만들어지는 경우는 흔치 않다. 이런 복사-붙여넣기가 잘못되었다는 건 많은 사람들이 알기 때문이다.

문제가 되는 경우는 함수의 일부분만 중복되는 경우이다. 함수 중간에 실행되어야 하는 로직만 다른 경우, 복사-붙여넣기 이후 달라져야 하는 부분만 코드를 수정하는 일이 종종 생기는데, 이런 식으로 중복 코드가 점점 늘어나게 되면 나중에 공통 로직 부분을 바꿔야 하는 경우 해당 구현을 복붙한 곳을 일일이 찾아다니면서 코드를 변경해야만 한다.

이런 중복을 방지하기 위해서는 다양한 디자인 패턴이 도움이 될 수 있다. e.g. 템플릿 메서드 패턴(template method pattern), 전략 패턴(strategy pattern) 등.

또 한 가지 중요한 포인트는 코드의 중복을 판단하는 기준이다. 코드의 중복은 '코드의 diff가 얼마나 적은가'가 아니라 '앞으로 코드가 변경할 방향성이 얼마나 동일한가'로 판단해야 한다. 지금 필요한 코드가 동일하더라도 앞으로 서로 독립적으로 변경될 수 있다면 과감히 복사-붙여넣기로 새로운 코드를 작성하는 게 더 나은 선택일 수 있다.

### 다형성을 활용한다.
다형성이란, 하나의 인터페이스 / symbol이 여러가지 의미를 가질 수 있는 성질을 의미한다. 상당히 추상적인 설명인데, 가장 대표적인 예시가 바로 인터페이스의 상속을 통한 다형성이다. 다음과 같은 코틀린 인터페이스를 생각해보자.

```kotlin
interface A {
    fun a()
}

class A1 : A {
    override fun a() {
        println("I'm A1")
    }
}

class A2 : A {
    override fun a() {
        println("I'm A2")
    }
}

fun runA(a: A) {
   a.a() // ????
}
```

위 예시에서, `runA()`를 실행시키면 인자 `a`에 어떤 클래스의 인스턴스가 들어오느냐에 따라 `I'm A1`이 출력될 수도, `I'm A2`가 출력될 수도 있다. 이 때 `a.a()`는 `A1.a()`가 될 수도 있고 `A2.a()`가 될 수도 있으므로 여러가지 의미를 가진다. 따라서 `a.a()`는 다형적이라고 할 수 있다.

다형성은 높은 코드 응집도에 큰 도움이 되는데, 기능이 자주 변경되는 축으로 다형성을 활용하면 코드의 응집도를 높일 수 있다. 다형성을 활용하여 코드의 응집도를 높일 수 있는 다양한 패턴은 GoF의 \<Design Patterns\>에 아주 상세히 소개되어 있으므로, 이 글에서 별도로 추가 서술하지는 않으려고 한다.

## Refs

- \<Implementing Domain-Driven Design\>
- [https://en.wikipedia.org/wiki/Dependency_inversion_principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)
- [https://en.wikipedia.org/wiki/Command–query_separation](https://en.wikipedia.org/wiki/Command%E2%80%93query_separation)
- [https://en.wikipedia.org/wiki/Polymorphism_(computer_science)](https://en.wikipedia.org/wiki/Polymorphism_(computer_science))
