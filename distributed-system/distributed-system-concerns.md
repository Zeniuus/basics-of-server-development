서버 개발을 하다 보면 분산 시스템 개발을 해야 하는 다양한 경우를 마주하게 된다. 서버를 여러 개로 나누어서 운영할 수도 있고, 외부 시스템과 연동을 해야 할 수도 있고, 데이터 팀이 제공하는 API를 사용해야 할 수도 있다. 이런 다양한 상황에서도 공통적으로 고민해야 하는 몇 가지 중요한 요소가 있다.

## 분산 시스템 개발의 어려움

분산 시스템을 개발하는 것은 하나의 프로세스로 동작하는 서버를 개발하는 것보다 일반적으로 더 어렵다. 분산 시스템 개발을 어렵게 만드는 이유에는 크게 두 가지가 있다.

### 1. 네트워크 호출이 언제든지 실패할 수 있다.

프로세스 바깥의 세상은 아주 불완전하고 불안하다. 통신하려는 서버에 장애가 발생했을 수 있다. DNS 서버에 오류가 발생하여 상대 서버의 IP를 조회하지 못할 수 있다. 네트워크 망에 장애가 발생했을 수 있다. 트래픽이 몰려 네트워크가 너무 느려지는 바람에 timeout이 날 수 있다. 이런 다양한 이유로 인해 외부와의 통신은 언제든지 실패할 가능성이 있다.

이는 마치 서버 코드에서 함수를 호출했는데 함수 호출이 랜덤한 확률로 실패하는 것과 같다. 분산 시스템을 개발할 때는 이러한 우연한 실패를 올바르게 다루는 방법이 필요하다.

### 2. 트랜잭션이 없다 → 상태가 깨질 수 있다.

트랜잭션은 비즈니스 로직 개발을 아주 쉽게 만들어주는 강력한 툴이다. 트랜잭션이 없다면 우리는 비즈니스 규칙에 따른 데이터 무결성과 정합성을 보장하기 위해 엄청난 노력을 기울여야 했을 것이다. 우리는 트랜잭션이 있기에 데이터 무결성과 정합성에 대해 큰 걱정을 하지 않아도 된다.

하지만 분산 시스템을 개발할 때는 트랜잭션을 활용할 수 없다. 서로 다른 두 개의 서버를 하나의 트랜잭션으로 묶을 수 없기 때문이다. 따라서 분산 시스템 개발을 하면 두 서버의 상태가 일치하지 않는, 즉 상태가 깨지는 순간이 반드시 존재할 수 있게 된다. 분산 시스템 개발을 할 때는 이러한 상태의 깨짐을 올바르게 다루는 방법이 필요하다.

## 어려움을 극복하는 방법

이제부터 각각의 어려움을 현명하게 극복하는 방법을 예시를 통해 알아보자.

### 1. 동기적인 네트워크 호출이 실패했을 경우

넷플릭스의 서버를 생각해보자. 넷플릭스 UI를 보면 유저에게 최적화된 추천 영화 리스트가 보여진다. 이러한 추천 영화 목록은 다른 전문적인 데이터팀이 개발한 ML 모델 서버가 노출한 API로부터 동기적으로 받아온다. 넷플릭스의 메인 서버는 유저가 넷플릭스 페이지를 켜면 이 API를 동기적으로 호출하고, 그 결과를 활용하여 추천 영화 목록을 보여준다. 하지만 이 API 호출은 (위에서 본 것처럼) 언제든지 실패할 수 있다. 이 경우 우리가 취할 수 있는 전략은 무엇일까?

1. 서버가 얼만큼의 autonomy(자율성)을 가져야 하는지 판단하자.

    가장 먼저 해야할 일은, 네트워크 요청이 실패하는 게 얼마나 "괜찮은" 일인지를 판단하는 것이다. 크게 두 가지 방향성이 있다.

    - 네트워크 요청이 실패하면 전체 요청을 실패시켜도 괜찮다. (서버가 automonous 하지 않다)
    - 네트워크 요청이 실패하더라도 나머지 로직은 정상적으로 동작해야 한다. (서버가 autonomous 하다)

    서버가 autonomous 한 게 무조건 좋아보일 수 있지만, 소프트웨어 개발은 언제나 트레이드 오프가 있다. 잠시 후에 살펴보겠지만, autonomy를 구현하기 위해서는 추가적인 노력이 필요하다. 상황에 따라 이 노력의 양이 엄청나게 커질 수도 있고, 아예 불가능에 가까울 수도 있다. 따라서 자신의 상황에 맞게 서버가 얼마나 autonomous 해야 하는지를 적절히 판단하는 것이 중요하다.

    넷플릭스의 예제에서는 아무래도 두 번째 방식을 택해야 할 것 같다. 즉, 추천 영화 목록 조회 API가 실패하더라도 넷플릭스 웹은 제대로 보여주는 게 좋을 것이다. 이 결정을 내렸으니 이제 다음 단계로 넘어가자.

2. autonomy를 구현하자.

    autonomy를 구현하는 방법을 알아보기에 앞서, 우리는 autonomy를 구현하려는 API의 성격을 분석해야 한다. 서버의 API에는 크게 두 가지 종류가 있다. 첫 번째는 서버에서 사용하는 엔티티의 상태를 변경하지 않고 조회만 하는 것이고, 두 번째는 엔티티의 상태를 변경시키는 것이다.

    2-1. 상대 서버의 상태를 변경하지 않는 경우

    이 경우 autonomy를 구현하는 방법에는 크게 두 가지 방식이 있다.

    - 로컬 서버에 fallback 로직을 구현한다 - 추쳔 영화 목록을 뽑아내는 fallback 로직을 로컬 서버에도 구현해서, API 요청이 실패하면 이 fallback 로직을 사용하게 한다. 이 때 fallback 로직은 매우 복잡할 필요는 없다. 그저 사용자가 위화감을 느끼지 않을 정도면 된다. 예를 들어 최근 한 달 영화 중 별점이 가장 높은 20개를 보여주는 방법이 있을 수 있다.
    - API의 결과를 로컬에 캐시한다 - 기존에 유저가 접속한 적이 있다면, 해당 유저에 대해 추천 영화 목록을 로컬 DB에 캐시한다. API 요청이 실패하면, 캐시가 너무 오래 되지 않은 경우에 한해 캐시된 추천 영화 목록을 보여준다.

    전자는 별도의 로직을 구현해야 하고 추천의 정확도가 떨어진다는 부담이 있지만, 언제나 문제 없이 동작할 것이다. 반면 후자는 추천의 정확도가 높지만, 유저가 오랜만에 접속했거나 한 번도 접속하지 않은 유저의 경우에는 동작하지 않는 방식이다. 그리고 추가적으로 유저가 많아질 경우 DB 저장공간을 많이 차지하게 될 수도 있다. 꼭 둘 중 하나를 선택하라는 법은 없다. 두 가지 방식을 모두 채택할 수도 있을 것이다. 하지만 이 경우에는 더 많은 시간을 투자하게 될 것이다.

    이 중 어떤 것을 선택하는 것이 적절한지는 상황에 따라 달라질 것이다. 필자라면 이 상황에서는 전자를 택할 것 같다. 캐시 데이터가 많아지는 게 부담이고, 추천 영화 목록 API가 실패할 가능성이 극히 낮아 보이기 때문이다.

    2-2. 상대 서버의 상태를 변경하는 경우

    이 경우에는 autonomy를 구현하기가 힘들다. 왜 그럴까?

    예시를 하나 들어보자. 어떤 서비스의 메인 서버 A가 있고, 이 서비스의 쿠폰 관련 로직을 담당하는 쿠폰 서버 B가 있다. 서버 A는 쿠폰 코드를 입력받아서 쿠폰을 발급하는 API를 노출하는데, 이 API가 호출되면 서버 A는 마치 프록시처럼 서버 B의 쿠폰 발급 API를 그대로 호출한다. 이 때 서버 A가 서버 B의 API를 호출하는 것이 실패할 수 있는데, 크게 두 가지 상황이 있을 수 있다.

    - 서버 B에서 요청이 정상적으로 처리되지 않았다.
    - 서버 B에서 요청이 정상적으로 처리되지 않았지만, 응답이 서버 A에 도달하지 않았다.

    이 두 가지 상황 중 서버 A는 어떤 상황이 발생했는지 모른다. 이 경우 서버 A가 autonomous 하기 위해서는 어떻게 해야 할까? 서버 B의 API 요청 실패에 대해 어떻게 처리하는 것이 "올바르게" 동작하는 것일까? 유저에게는 어떤 응답을 돌려줘야 할까? 유저에게는 쿠폰이 등록됐다고 해야 할까, 등록이 안 됐다고 해야 할까?

    상대 서버의 상태를 변경하는 API의 경우 상대 서버의 상태를 변경하는 데에 성공했는지 실패했는지를 알 수 없기 때문에 어떤 동작이 올바른 fallback인지 판단할 수 없다. 따라서 동기적인 호출로는 autonomy를 달성하기 어려워진다.

    이런 경우에는 동기적인 호출을 비동기적인 방식으로 변경하는 것이 하나의 해답일 수 있는데, 이는 eventual consistency 항목에서 더 자세히 알아보겠다.

### 2. 상태가 깨지는 경우

분산 시스템 개발 시에는 언제든지 두 서버의 데이터 무결성이 깨지는 경우가 발생할 수 있다. 예를 들어 일반적인 커머스 서비스를 생각해보자. 여기에는 유저의 주문을 받아주는 주문 서버와 주문대로 배송을 해주는 배송 서버가 있다. 주문이 들어오면 다음과 같은 일이 일어난다.

1. 주문 서버는 자신의 서버에 주문을 저장하고
2. 배송 서버에 주문을 전달해준다.
3. 배송 서버는 주문을 전달받으면 "배송 준비" 상태로 배송 건을 저장한다.
4. 배송 담당자는 어드민에 표시된 "배송 준비"인 배송 건을 보고 배송을 준비하기 시작한다.

하지만 주문 서버는 다양한 이유로 배송 서버에 주문이 들어왔다는 사실을 전달하는 데에 실패할 수 있다. 이 경우 우리는 어떻게 해야 할까?

- 상태가 깨지는 상황을 기획에 녹이기

    주문 서버가 배송 서버로 주문을 전달하는 데에 실패하는 것을 기술적으로 100% 막을 방법은 없다. 트랜잭션이 없기 때문이다. 100% 전달하려면 주문 서버와 배송 서버를 하나의 트랜잭션으로 묶는 수밖에 없다. 즉, 두 서버를 하나의 서버로 합치면 된다. 하지만 이런 방향이 언제나 우리가 원하는 방향은 아닐 뿐더러, 서버 통합이 아예 불가능한 상황도 빈번하게 있다.

    그렇다면 상태가 깨지는 상황을 극복할 방법은 정말 없는 것인가? 여기서는 생각의 전환이 필요하다. 주문 서버가 배송 서버에 주문을 전달해주지 못한 상황이 그렇게 큰 문제인가?

    커머스 서비스 없이 이 작업을 사람이 한다고 생각해보자. 주문을 받는 사람 A가 주문 서버가 하는 일을 대신하고, 배송을 준비하는 사람 B가 배송 서버가 하는 일을 대신한다. A는 주문을 받으면 이를 "주문 목록" 스프레드시트에 기록하고, B에게 이 주문을 전달한다. 이 때 A가 B에게 주문을 전달하는 데에는 어느 정도 시간이 걸리며, 이 시간 동안은 주문은 존재하지만 배송 건은 존재하지 않는 상태가 유지된다.

    여기서 하고 싶은 말은, 주문은 존재하지만 배송 건이 존재하지 않는 상태는 사람과 사람(혹은 서버와 서버)이 협력하는 상황에서는 아주 자연스러운 상태일 수 있다는 것이다. 현실에서는 모든 일이 동기적으로 일어나지 않는다. 마찬가지로 주문과 배송 건의 상태가 반드시 "즉시" 일치해야 하는 건 아니다. 적절한 시간 내에 주문에 맞는 배송 건이 생성되기만 하면 된다.

    따라서 상태가 깨지는 상황을 또 하나의 유효한 상태로 인정하고, 이를 기획과 프로덕트에 녹여내자. 이 상황에서는 주문이 존재하지만 배송 건이 존재하지 않으면 유저 주문 목록에 "배송 준비"로 보여주는 것이 합리적인 선택일 것이다.

- 깨진 상태를 복구하기 - eventual consistency

    위의 절에서 필자는 이렇게 이야기했다. "적절한 시간 내에 주문에 맞는 배송 건이 생성되기만 하면 된다." 상태가 즉시 일치해야 하는 건 아니지만, 언젠가는 일치하긴 해야 한다. 영원히 주문에 맞는 배송 건이 생성되지 않는다면 이는 주문이 누락된 것이다.

    이 "언젠가는 일치하는 것"이 바로 결과적 일관성, 즉 eventual consistency이다. 우리는 언젠가는 깨진 상태를 복구하여 무결성과 정합성이 유지되는 상태로 되돌아가야 한다. 주문이 들어왔으면 언젠가는 그에 맞는 배송 건이 생성되어야 한다.

    eventual consistency에 대한 더 자세한 내용은 [별도의 문서](/distributed-system/eventual-consistency.md)로 다룬다.

## Reference

- \<Implementing Domain-Driven Design\>
