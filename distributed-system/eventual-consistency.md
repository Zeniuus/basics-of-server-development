분산 시스템 환경에서는 분산된 서버에서 발생하는 여러 개의 변경을 하나의 트랜잭션으로 묶을 수 없다. 이 때문에 transactional consistency(트랜잭션적 일관성)를 달성할 수 없다. 즉, 분산된 서버의 여러 변경이 항상 동시에, 동기적으로 발생함을 보장할 수 없다는 뜻이다.

트랜잭션을 사용할 수 없다면 우리는 각 서버간의 consistency를 포기해야만 하는 것일까? 그렇지 않다. 이런 상황을 위해 우리는 eventual consistency(결과적 일관성)이라는 개념을 도입할 수 있다.

## Eventual consistency

### 개념

eventual consistency는 말 그대로 언젠가는 consistency가 지켜진다는 개념이다. 조금 더 풀어서 설명해보면, eventual consistency는 한쪽 서버에서 발생한 변화가 다른 쪽 서버에 즉시 전파되어 두 서버의 상태가 항상 일관되게 유지되는 것을 보장해주지는 않는다. 대신 어느 정도 시간이 흐르면 모종의 메커니즘으로 인해 양쪽 서버의 상태가 맞춰지고, 결과적으로 일관성을 달성할 수 있게 된다.

### 구현 전략

eventual consistency를 달성하려면 서버(이벤트를 생산하는 쪽)와 클라이언트(이벤트를 소비하는 쪽)의 올바른 협력이 필요하다. 기본적으로 다음의 두 가지를 구현해야 한다.

1. 성공할 때까지 재시도하기 (at least once) - 분산 시스템에서 서버의 변경이 클라이언트로 전파되기 위해서는 모종의 네트워크 통신이 필요하다. 그리고 이러한 네트워크 통신은 다양한 이유로 언제든지 실패할 수 있다. 따라서 eventual consistency를 달성하기 위해서는 네트워크 통신이 실패했을 때 서버의 변경을 다시 클라이언트로 전파하는 메커니즘이 필요하다. 즉, 변경의 전파가 성공할 때까지 재시도하는 로직이 필요하다.

    이러한 로직은 최소 한 번 이상 시도하는 로직이라고 해서 at least once 라고도 불린다.

2. 클라이언트의 멱등성 - 1번을 구현하면 추가적으로 발생하는 문제가 있다. 바로 클라이언트가 같은 이벤트를 여러번 수신할 가능성이 생긴다는 것이다. 다음과 같은 시나리오를 생각해보자.
    1. 서버가 클라이언트에 이벤트를 전파한다.
    2. 클라이언트는 이벤트를 수신하여 처리하고, 처리했다는 응답을 서버에 돌려준다.
    3. ii의 응답이 네트워크 오류로 인해 누락되어 서버에 전달되지 못한다.

    이 경우 서버는 클라이언트가 이벤트를 제대로 처리하지 못했다고 판단할 것이고, 1번의 재시도 로직에 의해 다시 한 번 클라이언트에 동일한 이벤트를 전파하려고 시도할 것이다. 이러면 클라이언트는 같은 이벤트를 두 번 수신하게 된다.

    이러한 경우를 대비하여 클라이언트는 이벤트 핸들러를 멱등적으로 구현해야 한다. 멱등적으로 구현한다는 것은 같은 이벤트를 중복 수신하더라도 마치 한 번만 수신한 것처럼 동작해야 한다는 뜻이다.

이제 각각의 요소를 구현할 때 구체적으로 고려해야 하는 부분에 대해 알아보자.

## at least once의 구현

at least once를 구현하기 위해서는 크게 두 가지 결정을 내려야 한다.

### 1. 이벤트 전파의 주체 - server push vs. client  pull

"이벤트를 전파한다"는 표현을 들으면 마치 서버가 클라이언트에게 네트워크 요청을 날려야 하는 것처럼 들린다. 이러한 방식을 server push 방식이라고 부른다. 하지만 이벤트의 전파는 다른 메커니즘으로도 가능하다. 클라이언트가 주기적인 polling 방식을 통해 아직 처리하지 못한 이벤트 목록을 서버로부터 조회해올 수도 있다. 이러한 방식은 client pull 방식이라고 한다.

이 두 가지 방식 중 어떤 것을 사용할지 선택할 때는 다양한 요소를 고려해야 한다.

- 한쪽 서버의 API가 이미 고정되어 있는 경우 - 외부 시스템을 연동할 경우, 일반적으로 해당 시스템의 API는 변경할 수 없다. 이런 경우에는 외부 시스템의 API에 맞는 전파 방식을 선택할 수밖에 없다.

    예를 들어 PG 서비스를 연동한다고 해보자. 해당 서비스가 결제 이벤트를 수신하는 API를 노출하고 있는 경우, 우리는 해당 API에 맞춰 서버를 구현해야 한다. PG사에 "우리가 결제건 조회 API를 노출할테니 그쪽에서 긁어가주세요"라고 하며 구현을 바꾸라고 할 수는 없는 노릇이다. 이런 경우에는 무조건 server push 방식을 사용해야 한다.

- 실시간성이 중요한 경우 - 기술적인 관점에서 조금 벗어나서, 통계적인 관점으로 눈을 돌려보자. 네트워크 호출의 성공과 실패는 각각 얼마나 자주 일어나는 일인가? 빈도로 따진다면 첫 네트워크 요청이 성공하여 재시도할 필요가 없는 경우가 대부분을 차지할 것이다.

    이런 통계적인 수치를 기반으로, 다음의 프렌차이즈 커피숍 예시를 생각해보자. 커피숍 앱으로 커피를 주문하면 이 주문 요청을 메인 서버가 저장하고, 해당 주문을 각 커피숍 지점의 기기로 전파해주고 있다. 이 경우에 client pull 방식을 사용하면 polling 주기 만큼 주문 전파에 딜레이가 생긴다. 예를 들어 polling 주기가 1분이라면 커피숍 지점이 주문을 받는 데는 최대 1분의 지연 시간이 발생하는 것이다. 반면, server push 방식을 택하면 대부분의 경우 유저가 주문을 넣자마자 커피숍 지점으로 주문이 전달될 수 있을 것이다.

    위와 같이 비즈니스 가치의 달성에 실시간성이 중요하면 중요할 수록 polling을 활용한 client pull 방식은 적합하지 않을 수 있다.

- 이벤트의 순서를 맞춰야 하는 경우 - [뒤에서 더 자세히 살펴보겠지만](/distributed-system/eventual-consistency.md#이벤트에-순서가-존재하는-경우), 비즈니스 로직을 구현하다 보면 서로 연관된 여러 이벤트가 발생하는 경우가 있다. 이럴 경우에는 eventual consistency의 달성이 더 까다로워진다.

    예를 들어 서버에서 서로 연관된 이벤트 1, 2, 3이 시간 순으로 발생한다고 해보자. 이 때 네트워크 통신의 불안정성 때문에 클라이언트는 1 → 2 → 3이 아닌 순서로 이벤트를 수신할 수도 있다. 예를 들어 이벤트 2의 전파만 누락되어 나중에 재시도가 된다면 클라이언트는 1 → 3 → 2의 순서로 이벤트를 수신할 것이다.

    이런 상황에서는 서버와 클라이언트 사이에는 이벤트의 순서를 맞추는 메커니즘이 필요하다. 이 때 client pull 방식을 사용하면 클라이언트는 적어도 중간에 발생한 이벤트를 누락시키고 확인할 염려는 없다. 즉, 이벤트 목록을 pull 했는데 2가 누락되고 1과 3만 보일 일은 없다는 뜻이다. 그래서 클라이언트는 그저 이벤트를 시간순으로 정렬해서 처리하기만 하면 된다. 한편 server push 방식은 이벤트의 순서를 맞추는 복잡한 메커니즘을 별도로 구현해야 한다.

### 2. 재시도의 구현 방식 - message queue vs. 자체 구현

이벤트 전달을 재시도하는 방식에는 크게 두 가지 방법이 있다.

- message queue 미들웨어 사용 - 이벤트를 message queue에 던지고, message queue가 at least once를 대신 수행하는 방식이다.

    message queue를 사용했을 때의 가장 큰 장점은 빠르게 구현할 수 있다는 점일 것이다. 우리는 재시도 로직을 직접 구현할 필요 없이 message queue가 알아서 재시도를 해준다.

    message queue를 사용할 때 주의해야 할 사항은 이벤트를 message queue에 넣는 행위가 실패할 수 있다는 것이다. 즉, 서버 쪽에서는 특정 변경이 이루어졌지만, 해당 변경에 대한 이벤트가 message queue에 들어가지 않을 수 있다. 이를 해결하기 위한 방법 중 하나로 로컬 DB를 message queue의 source로 활용하는 방법이 있다.

- 자체 구현 - 로컬 DB에 이벤트를 저장하고, 직접 server push 혹은 client pull을 구현하는 방식이다. cronjob을 활용하여 아직 클라이언트가 처리하지 못한 이벤트를 전송(server push) 혹은 조회(client pull)한다.

    이 방식은 message queue보다 비용이 많이 들지만, 자유도가 높다는 장점이 있다. message queue를 사용하면 message queue에서 지원하는 기능 이외에는 사용할 수 없지만, 직접 구현하면 원하는 만큼 기능을 확장할 수 있다.

## 멱등성의 구현

이벤트 처리에 대한 멱등성을 구현할 때는 두 가지 원칙이 필요하다.

- 이벤트의 식별자(ID) - 클라이언트가 특정 이벤트를 중복으로 수신한 건지 아닌지를 판단하기 위해 해당 이벤트에 전역적으로 유일한 식별자가 달려 있어야 한다. 클라이언트는 해당 식별자가 동일한 이벤트를 2회 이상 중복 수신한 경우 같은 이벤트를 수신했다고 판단한다.
- 멱등한 이벤트 핸들러 구현 - 같은 이벤트를 중복 수신한 경우 핸들러의 로직을 실행하지 않고 즉시 리턴한 뒤 처리 성공 응답을 돌려줘야 한다.

멱등성을 구현하는 원칙 자체는 상당히 간단해서, 이를 더 설명하기보다는 예시를 통해 멱등성을 실제로 어떻게 구현해야 하는지를 표현하는 게 더 좋을 것 같다.

### 예시 : PG사 연동

PG사를 연동하는 상황을 예시로 들어보겠다. 우리는 PG사 서버가 노출하고 있는 결제 요청 API를 연동해야 한다. 우리 서버가 결제 요청 API를 호출하면 PG사 서버는 동기적으로 결제 요청을 처리하고 결제 성공 / 실패 중 한 가지 응답을 내려줄 것이다.

이 경우 전파되는 이벤트는 우리 서버 → PG사 서버로 전파되는 결제 요청 이벤트일 것이다. 위에서 알아본 원칙에 따르면 우리는 결제 요청 이벤트에 유일한 식별자를 붙여서 PG사에 전송해야 한다. 아마 이벤트는 아래와 같이 생겼을 것이다.

```
{
  "transactionId": "ASDFASDFASDF", # globally unique ID
  # 결제 금액, 카드 정보 등 결제에 필요한 정보
}
```

위와 같은 이벤트에 대해 PG사 서버는 멱등적으로 이벤트 핸들러를 구현해야 한다. 여기서는 중복된 결제 요청을 받았을 경우 기존 결과(성공 or 실패)를 그대로 돌려주게 구현해야 할 것이다.

```kotlin
// PG사 서버
fun handlePayRequest(request: PayRequest): PayResult {
    val prevTransactionResult = transactionResultRepository.findByTransactionId(request.transactionId)
    if (prevTransactionResult != null) {
        return PayResult(
            transactionId = prevTransactionResult.transactionId,
            result = prevTransactionResult.result,
            transactedAt = prevTransactionResult.transactedAt,
            // 기타 필요한 정보
        )
    }
    
    // 결제 처리 로직

    val transactionResult = transactionResultRepository.save(TransactionResult(
        transactionId = request.transactionId,
        result = result,
        transactedAt = now,
        // 기타 필요한 정보
    ))

    return PayRequest(
        transactionId = transactionResult.transactionId,
        result = transactionResult.result,
        transactedAt = transactionResult.transactedAt,
        // 기타 필요한 정보
    )
}
```

짜잔, 우리는 안전하게 멱등성을 구현했다. 정말 그럴까? 우리는 한 가지 이벤트 전파를 놓치고 있다. 바로 결제 처리 완료 응답이다.

예를 들어 결제 처리 완료 응답을 수신하기 전에 우리 서버의 재시도 로직이 동작해서 결제 요청이 두 번 전달됐다고 해보자. 만약 결제가 성공했다면 우리 서버는 같은 `transactionId`에 대해 결제 성공이라는 응답을 두 번 수신하게 될 것이다. 만약 결제 성공 시에 발생하는 추가적인 로직(e.g. 유저에게 문자 발송 등)이 있다면 해당 로직이 두 번 실행될 수 있다. 따라서 우리는 결제 처리 완료 응답에 대한 핸들러도 멱등적으로 구현해야 한다.

```kotlin
// 우리 서버
fun handlePayResult(payResult: PayResult) {
    val paymentRequest = paymentRequestRepository.findByTransactionId(payResult.transactionId)
    val payResultStatus = PaymentRequestStatus.fromPayResult(payResult.result)
    if (paymentRequest.status == payResultStatus) {
        return
    }

    // 결제 처리 완료 응답 처리
}
```

## 이벤트에 순서가 존재하는 경우

우리는 지금까지 한 가지 요청, 한 가지 이벤트를 연동하는 경우에 대해서만 이야기했다. 하지만 비즈니스 로직을 구현하다 보면 서로 연관된 여러 이벤트가 발생할 수도 있다. 이들 사이에는 순서가 존재하며, 이 순서대로 다른 서버에 이벤트가 전파되지 않는다면 해당 이벤트를 수신한 서버는 잘못된 상태로 빠질 수도 있다. 즉, eventual consistency를 달성하는 데에 실패할 수도 있다.

예를 들어 지난 글에서 들었던 주문 서버와 배송 서버의 예시를 들어보자. 유저는 주문을 넣은 뒤에 배송지를 수정할 수 있는데, 배송지를 수정하면 다음과 같은 일이 일어난다.

1. 주문 서버는 변경된 배송지에 따라 배송비가 변경되었는지 확인하고 추가 결제 / 부분 환불을 일으킨다.
2. 주문 서버는 변경된 배송지를 배송 서버에 전달한다.

이 때 유저가 배송지를 A → B로, B → C로 변경했다고 하자. 만약 A → B 변경 이벤트의 전파가 누락 & 재시도되어 B → C 이벤트보다 늦게 주문 서버에 전파될 경우 배송 서버는 최종적으로 배송지를 B라고 잘못 알게 될 것이다.

이러한 문제를 방지하기 위해 크게 두 가지 전략을 사용할 수 있다.

### 1. 이벤트를 순서대로 처리하도록 보장하기

서버와 클라이언트는 적절히 협력하여 이벤트를 순서대로 처리하는 메커니즘을 구현할 수 있다. 이를 구현하는 방식은 server push와 client pull 중 어떤 방법으로 at least once를 구현했는지에 따라 상당히 달라진다.

- client pull - 서버는 이벤트를 저장할 때 서로 연관되어 있는 이벤트를 구분할 수 있는 이벤트 그룹 ID와 이벤트 발생 순서를 함께 저장한다. 클라이언트는 서버에 저장된 이벤트를 조회했을 때 같은 이벤트 그룹 ID를 가진 이벤트끼리는 이벤트 발생 순서에 맞춰서 이벤트를 처리한다.
- server push - 두 가지 방법이 있을 수 있다.
    - 첫 번째 방법은 서버 쪽에서 이벤트를 순서대로 전파하도록 보장하는 것이다. 서로 연관되어 있는 이벤트 1, 2, 3이 순서대로 발생하는데, 클라이언트가 1만 처리하고 2를 처리하지 못한 상태에서 3이 발생했다고 하자. 그러면 서버는 이벤트 3을 클라이언트에 전달하지 않고 이벤트 2의 전달을 계속 재시도한다. 클라이언트가 이벤트 2를 처리했다는 응답을 받으면 서버는 그제서야 이벤트 3을 전달하기 시작한다.

        이 방식의 가장 큰 문제는 직접 재시도를 구현하지 않는 상황에서는 사용하기 어렵다는 점이다. 예를 들어 message queue를 사용하고 있었다면, message queue에서 이벤트 순서에 맞춰 이벤트를 전파하는 기능을 제공해주지 않는 한 이 기능을 사용하기는 어렵다. 이럴 경우에는 반드시 클라이언트 쪽에서 이벤트 순서를 맞추는 메커니즘을 구현해야 한다.

    - 두 번째 방법은 클라이언트가 이벤트를 순서대로 처리할 수 있도록 이벤트 프로토콜을 설계하는 것이다. 이는 마치 TCP에서 순서를 맞추는 로직과 같다. 서버는 1. 서로 연관된 이벤트임을 알 수 있는 이벤트 그룹 ID와 2. 클라이언트가 이벤트의 순서를 알 수 있도록 1씩 단조 증가하는 sequence number를 이벤트에 달아서 저장한다. 클라이언트는 각 이벤트 그룹 ID마다 마지막으로 수신한 이벤트의 sequence number를 기억해두고, 그 다음 sequence number가 아닌 이벤트가 들어오면 처리에 실패했다고 응답을 돌려준다. 각 이벤트마다 at least once가 잘 구현되어 있다면 클라이언트는 언젠가는 이벤트 순서에 맞춰서 모든 이벤트를 처리할 수 있다.

개인적으로 client pull 방식이 가장 간단해 보이지만, 언제나 주어진 조건과 상황에 맞는 방법을 선택하는 것이 중요할 것이다.

### 2. 이벤트 대신 최종 상태를 연동하기

지금까지는 개별 이벤트를 연동하는 방법에 대해 논의했다. 하지만 개별 이벤트를 하나하나 연동하는 대신 최종 상태를 한 번에 연동하는 방법도 있다.

구현 방식은 비교적 간단하다. 주기적으로 상대 서버의 상태를 확인하여 현재 내 서버의 상태와 다를 경우 맞춰주면 된다. server push 방식일 경우 상대 서버가 내게 상태를 주기적으로 전송해줄 것이고, client pull 방식일 경우 내가 상대 서버의 상태를 주기적으로 조회해올 것이다.

위의 주문 서버 & 배송 서버의 예시를 다시 살펴보자. 주문 서버와 배송 서버는 각 배송지 변경 이벤트를 연동하는 대신, 최종적으로 변경된 배송지를 주기적으로 연동한다. 배송 서버는 같은 주문 건에 대해 주문 서버와 배송지가 다르면 주문 서버의 배송지로 자신의 배송지를 수정한다. 필요하면 배송 담당자에게 알림을 보낼 수도 있다.

얼핏 보면 상태를 연동하는 것보다 훨씬 간단해보이지만, 몇 가지 고려해야 하는 사항이 있다.

- 주고받는 데이터의 양 - 위 예시에서 사업이 엄청나게 성공해서 매일 주문이 100만건씩 들어온다고 해보자. 그러면 주문 서버와 배송 서버가 배송지를 한 번 연동할 때마다 어마어마한 양의 네트워크 트래픽이 발생할 것이다.

    이러한 문제를 방지하기 위해 서버 쪽에서 연동이 필요한 주문 건을 별도로 마킹해두고, 해당 마킹이 있는 주문 건만 배송 서버와 연동하는 전략을 사용할 수 있다. 예를 들면 주문 건에 version과 lastSyncedVersion 필드를 둔다. 주문 건의 배송지가 변경될 경우 version을 1 올리고, 배송 서버와 상태 연동에 성공했을 때 lastSyncedVersion 필드를 연동에 성공한 주문 건의 버전으로 갱신한다. 배송 서버에 연동할 때는 version > lastSyncedVersion인 주문 건만 데이터를 전송한다.

- 상태 sync 외에 다른 동작이 필요한 경우 - 위 예시에서는 배송지라는 상태만 연동하면 괜찮았기 때문에 최종 상태를 연동하는 방법을 사용할 수 있었다. 하지만 각각의 이벤트로 인해 클라이언트에서 추가적인 동작이 발생할 수 있고, 해당 동작이 비즈니스적으로 중요하다면 최종 상태를 연동하는 방법은 사용할 수 없다.

## Reference

- \<Implementing Domain-Driven Design\>
