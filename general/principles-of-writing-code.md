(작성 중)

이전에 이규원님이 작성하신 글 중에 [좋은 코드란 없고, 상황에 따른 적절한 코드만 존재한다는 논지의 글](https://gyuwon.github.io/blog/2020/07/31/what-is-good-code.html)이 있었다. 여기에 동의한다. 하지만 어떤 상황에서도 되도록이면 지키기 위해 노력해야 하는 공통된 개발 원칙들이 있다고 생각한다. 기본적으로는 이 원칙을 지키고, 필요에 따라 이 원칙과 다른 가치(e.g. 빠른 개발을 통한 proof of concept)를 트레이드 오프 하는 것이다.

이런 트레이드 오프가 가능하려면 우선 소프트웨어를 개발할 때 어떤 원칙을 지켜야 하고, 각 원칙이 어떤 효과를 가져다 주는지를 잘 이해하고 있어야 한다.

## 프로덕션 레벨의 소프트웨어가 가져야 하는 성질

나는 직군에 관계 없이 개발자가 두 가지 역할을 수행해야 한다고 생각한다.

- 요구사항을 만족하는 올바른 소프트웨어를 작성한다.
- 비즈니스 가치를 빠르게 전달할 수 있는 소프트웨어를 작성한다.

하지만 이 두 가지를 지키는 소프트웨어를 작성하는 것은 매우 어려운 일이다. 사업이 발전함에 따라 소프트웨어는 점점 거대해지고, 필연적으로 복잡해진다. 한 명의 개발자가 읽을 수 있는 코드의 양에는 한계가 있고, 엔터프라이즈 어플리케이션의 코드베이스 규모는 이 한계를 빠른 속도로 훌쩍 뛰어 넘는다. 기존에 있는 기능을 조금 수정해야 하는 상황을 생각해보자. 코드의 어떤 부분을 수정해야 하는지 파악하는 데에 한참이 걸리고, 기능 하나를 수정하기 위해 온갖 코드를 수정해야 하고, 코드를 조금 수정했을 뿐인데 엉뚱한 곳에서 버그가 터지는 일은 비일비재하게 발생한다.

따라서 위 두 가지 역할을 제대로 수행하기 위해, 개발자는 소프트웨어가 다음의 성질을 가지도록 소프트웨어를 작성해야 한다.

- **소프트웨어의 가독성** - 얼마나 빠르게 코드를 파악할 수 있는가?
- **소프트웨어의 자율성** - 얼마나 독립적으로 코드를 변경하고 프로덕션으로 배포할 수 있는가?
- **소프트웨어의 개발 속도** - 같은 기능을 얼마나 빠르게 반영할 수 있는가?

다행히 이미 많은 소프트웨어 개발의 대가들이 같은 고민을 했고, 위와 같은 소프트웨어를 만들기 위한 수많은 방법론을 고안해냈다. 이런 방법론을 공부할 때 공통적으로 등장하는 개념과 추구하는 목표가 몇몇 존재하는데, 이들을 정리해보았다.

## 원칙 1. 의존성의 올바른 관리

거대하고 복잡한 소프트웨어는 수많은 소프트웨어 컴포넌트들의 통합과 협업을 통해 만들어진다. 코드 레벨에서는 다른 클래스의 변수 및 전역 변수를 사용하거나 함수를 호출한다. 프로세스 레벨에서는 네트워크 통신을 통해 다른 서버가 노출하는 API를 사용하거나, 다른 프로세스가 저장해놓은 데이터를 가져다 사용할 수도 있다. 이렇게 한 소프트웨어 컴포넌트가 다른 소프트웨어 컴포넌트의 기능을 직/간접적으로 가져다 사용하는 것을 '**의존**'이라고 부른다.

의존은 소프트웨어를 작성할 때 필연적으로 발생하지만, 의존을 올바르게 하지 않으면 문제가 발생한다. A라는 소프트웨어 컴포넌트가 B라는 소프트웨어 컴포넌트에 의존하는 상황을 생각해보자(A→B). 이 경우 A를 변경하는 것은 큰 문제가 안 된다. 반면, B를 수정하는 것은 조금 골치 아프다. B를 수정할 때 A가 올바르게 동작하는 것까지 고려해야 하기 때문이다.

- B의 기능을 변경하려면 B에 대한 새 요구사항을 지키는 것뿐만 아니라 A가 B의 기능을 사용하는 유즈 케이스에 대해서도 요구사항이 지켜져야만 한다.
- 만약 B의 인터페이스를 바꿔야 하는 상황이라면 더욱 문제가 크다. 필연적으로 A에서 B를 사용하는 코드도 함께 수정해야 하기 때문이다.
- 만약 A가 다른 팀이 관리하고 있는 컴포넌트라면 B의 변경 비용은 더욱 커질 것이다. B를 수정해야 하는 필요성에 대해 다른 팀을 설득하고, A에 대한 하위호환성도 고려해야 한다.
- 만약 B에 의존하는 소프트웨어 컴포넌트가 더 많다면(C→B, D→B, ...) B의 변경 비용은 더욱 커질 것이다.

**위에서 본 것처럼, 의존성은 소프트웨어 변경의 비용을 높인다. 따라서 의존성을 올바르게 관리하는 것이 필요하다.**

- 필요하지 않는 의존은 하지 않는다.
    - 많이 의존받는 소프트웨어에는 되도록이면 공통된 정보 / 기능만 넣는다. A→C / B→C인데 A에만 필요한 기능을 C에 넣지 않는다.
- 의존이 필요한 경우, 자주 변경되지 않는 소프트웨어에 의존한다.
    - DIP - e.g. callback(의존성 그림 필요), 레이어드/헥사고날 아키텍처에서의 인프라 레이어
- 의존 포인트를 통합한다.
    - e.g. 퍼사드 패턴

## 원칙 2. 분명한 인터페이스 디자인

아무런 계획 없이 소프트웨어를 작성하다 보면, 구현하기 편한 방식으로 끊어서 컴포넌트를 묶게 된다. 예를 들어 함수를 작성하다가 단순히 길어져서 함수를 분리하는 경우를 생각해보자. 이 때 분리된 함수의 시그니처는 어떻게 될까? 분리된 함수 내에서 사용되지만 선언하지 않아서 IDE에 빨간색으로 표시되는 변수를 인자로 받게 될 가능성이 크다. 이러면 함수의 의미를 파악하기 힘들고, 재사용성이 떨어지게 된다.

**따라서 구현하기 편한 인터페이스가 아니라, 읽고 가져다 쓰기 편한 인터페이스를 작성해야 한다.** 이는 소프트웨어를 작성하는 빈도보다 해당 소프트웨어를 읽고 가져다가 사용하는 빈도가 훨씬 잦기 때문이다. 인터페이스를 통해서 해당 컴포넌트가 하는 일이 분명하게 드러나지 않으면, 해당 컴포넌트를 사용하는 사람은 불안해서 컴포넌트의 내부 구현을 까보게 된다. 이러면 코드를 분리한 이유가 사라진다. 내부 구현을 몰라도 인터페이스만 보면 명확하게 목적과 용도가 파악되는 소프트웨어를 작성해야 한다.

여기서 말하는 인터페이스는 단순히 클래스의 인터페이스만을 포함하는 게 아니다. 소프트웨어 컴포넌트 간의 의존이 발생하는 모든 '접점'을 의미한다. 클래스의 퍼블릭 변수 및 전역 변수의 이름과 타입, 함수의 시그니처, HTTP API, DB 테이블 스키마 등 수많은 다양한 접점이 존재하고, 이들은 모두 일종의 인터페이스로 생각할 수 있다.

좋은 인터페이스를 설계하기 위해서는 아래와 같은 방법이 도움이 된다.

- 단일 시멘틱 원칙을 지킨다.
    - 단일 시멘틱 원칙은 내가 임의로 붙인 이름으로, 하나의 필드 / 함수 / 클래스는 하나의 의미만을 가져야 한다는 원칙이다. 이에 대한 마틴 파울러의 훌륭한 코멘트가 있다. "역할이 둘 이상인 변수가 있다면 쪼개야 한다. 예외는 없다. 역할 하나당 변수 하나다."
    - 이는 결국 예상치 못한 일을 방지하기 위함이다. 소프트웨어 컴포넌트가 인터페이스에서 예측하는 것과는 다른 행동을 하지 않게 만들어야 한다.
    - 비슷한 예시로 Command-Query Segregation(CQS)가 있다. query method인 것처럼 생긴 함수가 알고 보니 DB 테이블을 수정하고 있었다면 예상치 못한 사이드 이펙트가 발생할 수 있다.
- 테스트를 작성한다.
    - 좋은 인터페이스를 설계하는 데에 큰 도움이 되는 것은 테스트를 작성하는 것이다. 테스트를 작성하면 컴포넌트를 실제로 사용하는 코드를 작성하게 되기 때문에, 해당 컴포넌트가 어떻게 사용될지를 자연스럽게 고려하게 된다.

## 원칙 3. 높은 코드 응집도

소프트웨어를 작성하다 보면 하나의 기능과 관련된 코드가 여기저기 흩뿌려지는 경우가 많다. 이런 코드베이스에서는 한 가지 기능을 수정할 때 코드의 수많은 부분을 건드려야만 한다. 이는 개발 속도를 현저하게 감소시킨다. 어디를 고쳐야 하는지 일일이 찾아야 하고, 각 부분을 올바르게 수정해야 하고, 수정했을 때 해당 코드에 의존하는 다른 기능들이 영향을 받지 않았는지 확인해야 한다. 함께 고쳐야 하는 부분이 서로 다른 서버에 퍼져 있을 때는 배포 전략도 추가적으로 수립해야 한다.

**따라서 특정한 기능을 수정할 때 코드의 여러 부분을 수정하는 게 아니라 한 부분만 수정하면 되도록 소프트웨어를 유지해야 한다.** 그래야 코드를 수정할 때의 비용이 낮아지고, 비즈니스 가치를 시장에 빠르게 전달할 수 있다.

- 중복된 코드를 만들지 않는다.
    - 코드 중복은 기능의 응집도가 낮다는 것을 알리는 대표적인 시그널이다. 반복되는 코드는 하나로 합쳐야 한다.
    - 이는 간단하고 당연해 보이지만, 실제 프로덕선 레벨에서는 코드 중복이 빈번하게 발생한다. 왜냐하면 생각보다 지키기 어렵기 때문이다. 함수를 예시로 들어보자. 완전히 동일한 함수를 복사-붙여넣기해서 중복이 만들어지는 경우는 흔치 않다. 많은 경우에는 함수의 일부분을 재사용하기 위해 복사-붙여넣기를 하고 조금 수정해서 중복이 발생한다.
    - 이런 중복을 방지하기 위해서는 다양한 디자인 패턴이 도움이 될 수 있다. e.g. 템플릿 메서드 패턴(template method pattern), 전략 패턴(strategy pattern) 등
    - 또 한 가지 중요한 포인트는 코드가 중복되었는지 판단하는 기준이다. 코드의 중복은 얼마나 코드의 diff가 적은가가 아니라 앞으로 코드가 변경할 방향성이 얼마나 동일한가로 판단해야 한다.
- 다형성을 활용한다.
    - 기능이 자주 변경되는 축으로 다형성을 활용하면 코드의 응집도를 높일 수 있다.
